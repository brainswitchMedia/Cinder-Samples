/* 
 Tessellation Shader from Philip Rideout
 
 "Triangle Tessellation with OpenGL 4.0"
 http://prideout.net/blog/?p=48 */

#version 400

layout(triangles, equal_spacing, cw) in;

uniform mat3        ciNormalMatrix;
uniform mat4        ciViewMatrix;
uniform float       uDisplacement;

uniform samplerCube uHeightMap;
uniform samplerCube uTranslucencyMap;
uniform samplerCube uNormalMap;

in vec3             tcPosition[];
in vec3             tcNormal[];
in vec2             tcTexCoord[];
in vec3             tcTangent[];

out vec3            tePosition;
out vec2            teTexCoord;
out vec3            teNormal;
out vec3            teTangent;
out vec3            teTexCoord3D;

out vec3            tePatchDistance;

void main()
{
    vec3 n0 = gl_TessCoord.x * tcNormal[0];
    vec3 n1 = gl_TessCoord.y * tcNormal[1];
    vec3 n2 = gl_TessCoord.z * tcNormal[2];
    vec3 normal = normalize( n0 + n1 + n2 );

    vec3 t0 = gl_TessCoord.x * tcTangent[0];
    vec3 t1 = gl_TessCoord.y * tcTangent[1];
    vec3 t2 = gl_TessCoord.z * tcTangent[2];
    vec3 tangent = normalize( t0 + t1 + t2 );
    
    vec2 tc0 = gl_TessCoord.x * tcTexCoord[0];
    vec2 tc1 = gl_TessCoord.y * tcTexCoord[1];
    vec2 tc2 = gl_TessCoord.z * tcTexCoord[2];
    teTexCoord = tc0 + tc1 + tc2;
    
    vec3 p0 		= gl_TessCoord.x * tcPosition[0];
    vec3 p1 		= gl_TessCoord.y * tcPosition[1];
    vec3 p2 		= gl_TessCoord.z * tcPosition[2];
    tePatchDistance = gl_TessCoord;
    tePosition 		= normalize( p0 + p1 + p2 );
    
    vec3 texCoord3D = vec3( tePosition );
    
    float height = texture( uHeightMap, texCoord3D ).x;

    tePosition += normal * ( height * uDisplacement);

    gl_Position 	= vec4( tePosition, 1.0 );
    teNormal        = normal;
    teTangent       = tangent;
    teTexCoord3D    = texCoord3D;
}
